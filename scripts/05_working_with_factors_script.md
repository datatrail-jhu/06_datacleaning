In R, categorical data are handled as factors. 

By definition, categorical data are limited in that they have a set number of possible values they can take. For example, there are 12 months in a calendar year. In a month variable, each observation is limited to taking one of these twelve values. Thus, with a limited number of possible values, month is a categorical variable. Categorical data, which will be referred to as factors for the rest of this lesson, are regularly found in data. Learning how to work with this type of variable effectively will be incredibly helpful.

To make working with factors simpler, we'll utilize the forcats package. Before working through this lesson, you'll want to be sure that forcats has been installed and loaded in using the install dot packages and library functions.

Similar to the stringr package, all functions within forcats begin with f c t underscore . As before, to see available functions you can type question mark f c t underscore  in your RStudio console. A drop-down menu will appear with all the possible forcats functions. 

In R, factors are comprised of two components: the actual values of the data and the possible levels within the factor. Thus, to create a factor, you need to supply both these pieces of information. For example, if we were to create a character vector of the twelve months, we could certainly do that using this code. However, if we were to sort this vector, R would sort this vector alphabetically. While you and I know that this is not how months should be ordered, we haven't yet told R that. 

To do so, we need to let R know that it's a factor variable and what the levels of that factor variable should be. Here, we specify all the possible values that the factor could take in the levels equals all_months argument. So, even though not all twelve months are included in the some_months object, we've stated that all of the months are possible values. Further, when you sort this variable, it now sorts in the sensical way!

What if you wanted your months to start with July first? That can be accomplished using f c t underscore relevel. To use this function, you simply need to state what you'd like to relevel (mon) followed by the levels you want to relevel. If you want these to be placed in the beginning, the after argument should be after equals 0. You can play around with this setting to see how changing after affects the levels in your output. After re-leveling, when we sort this factor, we see that July is placed first, as specified by the level re-ordering.

Now, if you're not interested in the months being in calendar year order, you can always state that you want the levels to stay in the same order as the data you started with, you simply specify f c t underscore in order. We see now with f c t underscore in order that even when we sort the output, it does not sort the factor alphabetically, nor does it put it in calendar order. In fact, it stays in the same order as the input, just as we specified.

For the remainder of this lesson, we're going to return to using a dataset that's in R by default. We'll use the chicken weights dataset for exploring the remaining advanced functions. This data set includes data from an experiment that was looking to compare the "effectiveness of various feed supplements on the growth rate of chickens."

To re-order factor levels by frequency of the value in the dataset, you'll want to use f c t underscore infreq. Here, we see from the output from janitor's tabyl function that 'soybean' is the most frequent feed in the data set while 'horsebean' is the least frequent. Thus, when we order by frequency, we can expect these two feeds to be at opposite ends for our levels. As expected, soybean, the most frequent level, appears as the first level and horsebean, the least frequent level, appears last. The rest of the levels are sorted by frequency. 

If we wanted to sort the levels from least frequent to most frequent, we could just put f c t underscore rev around the code we just used to reverse the factor level order.

At times you may want to reorder levels of a factor by another variable in your dataset. This is often helpful when generating plots (which we'll get to in a future lesson!). To do this you specify the variable you want to reorder, followed by the numeric variable by which you'd like the factor to be re-leveled. Here, we see that we're re-leveling feed by the weight of the chickens.  While we haven't discussed plotting yet, the best way to demonstrate how this works is by plotting the feed against the weights. We can see that the order of the factor is such that those chickens with the lowest median weight (horsebean) are to the left, while those with the highest median weight (casein) are to the right.

To demonstrate how to combine several factor levels into a single level, we'll continue to use our chickwts dataset. Now, I don't know much about chicken feed, and there's a good chance you know a lot more. However, let's assume (even if it doesn't make good sense with regards to chicken feed) you wanted to combine all the feeds with the name "bean" in it to a single category and you wanted to combine "linseed" and "sunflower"" into the category "seed". This can be simply accomplished with f c t underscore recode. In fact, below, you see we can rename all the levels to a simpler term (the values on the left side of the equals sign) by re-naming the original level names (the right side of the equals sign). This code will create a new column, called feed_recode (accomplished with mutate). This new column will combine "horsebean" and "soybean feeds", grouping them both into the larger level "bean". It will similarly group "sunflower" and "linseed" into the larger level "seed." All other feed types will also be renamed. When we look at the summary of this new column by using janitor's tabyl function, we see that all of the feeds have been recoded, just as we specified! We now have four different feed types, rather than the original six.

Finally, when working with factors, there are times when you want to convert a numeric variable into a factor. For example, if you were talking about a dataset with BMI for a number of individuals, you may want to categorize people based on whether or not they are underweight, meaning having a BMI less than 18.5, of a healthy weight, meaning having a BMI between 18.5 and 29.9, or obese, which are individuals whose BMI is greater than or equal to 30). When you want to take a numeric variable and turn it into a categorical factor variable, you can accomplish this easily by using if else statements. if statements and else statements were covered in an earlier lesson. Here we combine those two ideas. Within a single statement we provide R with a condition: weight less than or equal to 200. With this, we are stating that the condition we are specifying is if a chicken's weight is less than or equal to 200 grams. Then, if that condition is true, meaning if a chicken's weight is less than or equal to 200 grams, let's assign that chicken to the category low. Otherwise, and this is the else part of the ifelse function, assign that chicken to the category high. Finally, we have to let R know that weight_recode is a factor variable, so we call factor on this new column. This way we take a numeric variable weight, and turn it into a factor variable weight underscore recode. 

This lesson has covered how to work with factors (categorical) variables in R using the forcats package in R. In line with the previous few lessons, the best way to learn how to work with factors, is to actually work with factors. Play around with the examples here and continue to practice using this type of variable! You'll come across factors regularly as you analyze data!